# Сети в Linux
_____
#### Настройка сетей в Linux на виртуальных машинах.
_____
## Содержание:

1. [Part 1. Инструмент ipcalc](#part-1-инструмент-ipcalc)

[Поднять виртуальную машину (далее -- ws1)](#поднять-виртуальную-машину-далее--ws1)

1.1. [Сети и маски](#сети-и-маски)

1.2. [localhost](#localhost)

1.3. [Диапазоны и сегменты сетей](#диапазоны-и-сегменты-сетей)

2. [Part 2. Статическая маршрутизация между двумя машинами](#part-2-статическая-маршрутизация-между-двумя-машинами)

2.1. [Добавление статического маршрута вручную](#добавление-статического-маршрута-вручную)

2.2. [Добавление статического маршрута с сохранением](#добавление-статического-маршрута-с-сохранением)

3. [Part 3. Утилита iperf3](#part-3-утилита-iperf3)

3.1. [Скорость соединения](#скорость-соединения)

3.2. [Утилита iperf3](#утилита-iperf3)

4. [Part 4. Сетевой экран](#part-4-сетевой-экран)

4.1. [Утилита iptables](утилита-iptables)

4.2. [Утилита nmap](утилита-nmap)

5. [Part 5. Статическая маршрутизация сети](#part-5-статическая-маршрутизация-сети)

  5.1 [Настройка адресов машин](настройка-адресов-машин)

  5.2 [Включение переадресации IP-адресов](включение-переадресации-ip-адресов)

  5.3 [Установка маршрута по-умолчанию](установка-маршрута-по-умолчанию)

  5.4 [Добавление статических маршрутов](добавление-статических-маршрутов)

  5.5 [Построение списка маршрутизаторов](построение-списка-маршрутизаторов)

  5.6 [Использование протокола ICMP при маршрутизации](#использование-протокола-icmp-при-маршрутизации)

6. [Part 6. Динамическая настройка IP с помощью DHCP](#part-6-динамическая-настройка-ip-с-помощью-dhcp)

7. [Part 7. NAT](#part-7-nat)

8. [Part 8. Дополнительно. Знакомство с SSH Tunnels](#part-8-дополнительно-знакомство-с-ssh-tunnels)

_____
# Part 1. Инструмент ipcalc

## Поднять виртуальную машину (далее -- ws1)
![screen1.1](screen/screen1.1.png)
Для начала работы установливаем инструмент **ipcalc**. Для этого используем команду:
```C
sudo apt install ipcal
```
## 1.1. Сети и маски
**1) адрес сети 192.167.38.54/13**
+ Для определения адреса сети 192.167.38.54/13 вводим команду 
```C
ipcalc 192.167.38.54/13
```
![screen1](screen/screen1.png)
**Network** - это адрес сети, в которой находится наш IP. Справа он же, но в двоичном коде

**2) перевод маски 255.255.255.0 в префиксную и двоичную запись, /15 в обычную и двоичную, 11111111.11111111.11111111.11110000 в обычную и префиксную**
Для начала определяем актуальный IP-адрес подсети с помощью команды:
```C
ip address
```
![screen2.1](screen/screen2.1.png)
+ **Перевод маски 255.255.255.0 в префиксную и двоичную запись**
Вводим команду 
```C
ipcalc 10.0.2.15/24 255.255.255.0
```
![screen3](screen/screen3.png)
**Netmask** - это маска подсети. Справа она же, но в двоичном коде.
+ **/15 в обычную и двоичную запись**
Вводим команду 
```C
ipcalc 10.0.2.15/15
```
![screen4](screen/screen4.png)
Обычная и двоичная запись /15
+ **11111111.11111111.11111111.11110000 в обычную и префиксную**
Сначала конвертируем двоичную запись 11111111.11111111.11111111.11110000 в десятичное представление
Первые 8 битов: 11111111 = 255
Следующие 8 битов: 11111111 = 255
Следующие 8 битов: 11111111 = 255
Последние 4 бита: 11110000 = 240
В итоге десятичное представление маски подсети 11111111.11111111.11111111.11110000 равно 255.255.255.240.
Применяем команду 
```C
ipcalc 10.0.2.15 255.255.255.240
```
![screen5](screen/screen5.png)
Обычная и префиксная запись 11111111.11111111.11111111.11110000.
**3) минимальный и максимальный хост в сети 12.167.38.4 при масках: /8, 11111111.11111111.00000000.00000000, 255.255.254.0 и /4**
+ минимальный и максимальный хост в сети 12.167.38.4 при маске: /8
Применяем команду:
```C
ipcalc 12.167.38.4/8
```
![screen6](screen/screen6.png)
минимальный и максимальный хост в сети 12.167.38.4 при масках: /8
+ минимальный и максимальный хост в сети 12.167.38.4 при маске: 11111111.11111111.00000000.00000000
Сначало конвертируем двоичную запись маски подсети в префиксную запись. Для этого подчитываем количество значащих бит в двоичной записи маски (те, которые равны 1). Записываем количество значащих бит в виде числа и добавляем символ "/"ю Применяем команду:
```C
ipcalc 12.167.38.4/16
```

![screen6](screen/screen7.png)
минимальный и максимальный хост в сети 12.167.38.4 при маске: 11111111.11111111.00000000.00000000
+ минимальный и максимальный хост в сети 12.167.38.4 при маске: 255.255.254.0
Применяем команду:
```C 
ipcalc 12.167.38.4 255.255.254.0
```
![screen6](screen/screen8.png)
минимальный и максимальный хост в сети 12.167.38.4 при маске: 255.255.254.0
+ минимальный и максимальный хост в сети 12.167.38.4 при маске: /4
Применяем команду:
```C
ipcalc 12.167.38.4/4
```
![screen9](screen/screen9.png)
минимальный и максимальный хост в сети 12.167.38.4 при масках: /4

## 1.2. localhost
**Определить и записать в отчёт, можно ли обратиться к приложению, работающему на localhost, со следующими IP: 194.34.23.100, 127.0.0.2, 127.1.0.1, 128.0.0.1**
Вводим команду 
```C
ipcalc IP
```
Эта команда дает информацию о расчете сетевых характеристик для IP-адреса 127.1.0.1. 
Если в строке **Hosts/Net** видим **Loopback**: это означает, что данный IP-адрес принадлежит к петлевой (loopback) сети. Петлевая сеть (обычно 127.0.0.0/8) используется для тестирования и обращения к приложениям на локальной машине. IP-адрес  является частью этой петлевой сети, то обычно используется для обращения к самой системе (localhost).
Таким образом определяем можно ли обратиться к приложению, работающему на localhost:
![screen10](screen/screen10.png)
Вывод: нельзя обратиться к приложению, работающему на localhost, с IP: 194.34.23.100 
![screen11](screen/screen11.png)
Вывод: можно обратиться к приложению, работающему на localhost, с IP: 127.0.0.2 
![screen12](screen/screen12.png)
Вывод: можно обратиться к приложению, работающему на localhost, с IP: 127.1.0.1
![screen13](screen/screen13.png)
Вывод: нельзя обратиться к приложению, работающему на localhost, с IP: 128.0.0.1
## 1.3. Диапазоны и сегменты сетей
**Определить и записать в отчёт:**

**1) какие из перечисленных IP можно использовать в качестве публичного, а какие только в качестве частных: 10.0.0.45, 134.43.0.2, 192.168.4.2, 172.20.250.4, 172.0.2.1, 192.172.0.1, 172.68.0.2, 172.16.255.255, 10.10.10.10, 192.169.168.1**
Диапазон общедоступных IP-адресов включает все номера, не зарезервированные для диапазона частных IP-адресов. Частные IP-адреса, зарезервированные Управлением по присвоению номеров в Интернете (IANA), в следующих диапазонах:
```
Класс А: 10.0.0.0 – 10.255.255.255
Класс Б: 172.16.0.0 – 172.31.255.255
Класс С: 192.168.0.0 – 192.168.255.255
```
Таким образом определяем **публичные** IP адреса из задания:
```
134.43.0.2
172.0.2.1
192.172.0.1
172.68.0.2
192.169.168.1
```
Определяем **частные** IP адреса из задания: 
```
10.0.0.45,
192.168.4.2,
172.20.250.4,
172.16.255.255,
10.10.10.10
```
Это можно проверить при вводе команды `ipcalc IP` в строке Hosts/Net наличием или отсуствием записи `Private Internet`
![screen15](screen/screen15.png)
**2) какие из перечисленных IP адресов шлюза возможны у сети 10.10.0.0/18: 10.0.0.1, 10.10.0.2, 10.10.10.10, 10.10.100.1, 10.10.1.255**
для начала определим диапазон IP-адресов, соответствующего сети 10.10.0.0/18:
```
ipcalc 10.10.0.0/18
```
![screen14](screen/screen14.png)
Определяем какие из перечисленных IP адресов шлюза возможны у сети 10.10.0.0/18:
- [ ] 10.0.0.1 не возможен
- [x] 10.10.0.2 возможен
- [x] 10.10.10.10 возможен
- [ ] 10.10.100.1 не возможен
- [x] 10.10.1.255 возможен 
___
## Part 2. Статическая маршрутизация между двумя машинами
## Поднять две виртуальные машины (далее -- ws1 и ws2)
![screen16](screen/screen16.png)
**С помощью команды ip a посмотреть существующие сетевые интерфейсы**
+ В отчёт поместить скрин с вызовом и выводом использованной команды.
Смотрим существующие сетевые интерфейсы с помощью команды `ip a`
![screen17.1](screen/screen17.1.png)
Вызов и вывод команды `ip a` ws1
![screen17.2](screen/screen17.2.png)
Вызов и вывод команды `ip a` ws2
**Описать сетевой интерфейс, соответствующий внутренней сети, на обеих машинах и задать следующие адреса и маски: ws1 - 192.168.100.10, маска /16, ws2 - 172.24.116.8, маска /12**

Опишем сетевой интерфейс:

Машина **ws1**:
Имя интерфейса: enp0s3
Состояние: UP (активен)
MAC-адрес: 08:00:27:01:9a:02 (фактический MAC-адрес устройства)
IP-адрес: 10.0.2.15
Маска подсети: /24 (255.255.255.0)
Описание: Сетевой интерфейс "enp0s3" на машине ws1 подключен к внутренней сети. Его IP-адрес 10.0.2.15 находится в диапазоне Класс А: 10.0.0.0 – 10.255.255.255 с маской подсети /24.

Машина **ws2**:
Имя интерфейса: enp0s3
Состояние: UP (активен)
MAC-адрес: 08:00:27:5e:0f:90 (фактический MAC-адрес вашего устройства)
IP-адрес: 10.0.2.15
Маска подсети: /24 (255.255.255.0)
Описание: Сетевой интерфейс "enp0s3" на машине ws2 также подключен к внутренней сети. Его IP-адрес 10.0.2.15 находится в диапазоне Класс А: 10.0.0.0 – 10.255.255.255 с маской подсети /24.

+ **В отчёт поместить скрины с содержанием изменённого файла etc/netplan/00-installer-config.yaml для каждой машины.**
Для изменения файла `etc/netplan/00-installer-config.yaml` выполняем команду:
```C
$sudo vim /etc/netplan/00-installer-config.yaml
```
![screen19](screen/screen19.11.png)
  * Отчет с описанием с заданными адресами и масками: ws1 - 192.168.100.10, маска /16, ws2 - 172.24.116.8, маска /12

**Выполнить команду netplan apply для перезапуска сервиса сети**
Выполняем команду для перезапуска сервиса сети
```C
sudo netplan apply
```
+ В отчёт поместить скрин с вызовом и выводом использованной команды.
![screen20.2](screen/screen20.2.png)
вызов использованной команды для ws1
![screen20.1](screen/screen20.1.png)
вызов использованной команды для ws2
![screen20.4](screen/screen20.4.png)
вывод использованной команды для ws1
![screen20.3](screen/screen20.3.png)
вывод использованной команды для ws2

## 2.1. Добавление статического маршрута вручную

**Добавить статический маршрут от одной машины до другой и обратно при помощи команды вида `ip r add`**

Чтобы вывести текущую таблицу маршрутизации выполняем команду:
```C
ip r
```
![screen21.1](screen/screen21.1.png)
ws1. Cтатический маршрут для сети 1192.168.0.0/16 через адрес 192.168.100.10, который прописан на интерфейсе
![screen21.2](screen/screen21.2.png)
ws2. Cтатический маршрут для сети 172.168.0.0/12 через адрес 172.24.116.8, который прописан на интерфейсе
Добавляем статический маршрут от одной машины ws1 к другой ws2 с помощью команды:
```C
sudo ip r add 172.24.116.8 dev enp0s3
```
![screen21.5](screen/screen21.5.png)
Добавляем статический маршрут от одной машины ws2 к другой ws1 с помощью команды:
```C
sudo ip r add 192.168.100.10 dev enp0s3
```
![screen21.4](screen/screen21.4.png)

**Пропинговать соединение между машинами**
+ В отчёт поместить скрин с вызовом и выводом использованных команд.
Чтобы пропинговать соединение  между двумя машинами ws1 и ws2 выполняем команду `ping`
Остановить выполнение команды ping, нажмаем `Ctrl + C`. 
![screen21.6](screen/screen21.6.1.png)
![screen21.7](screen/screen21.7.1.png)
Пропинговали соеденения между машинами.

## 2.2. Добавление статического маршрута с сохранением

**Перезапустить машины**
Для перезагрузки виртуальной машины виспользуем команду `reboot`
```C
sudo reboot
```
**Добавить статический маршрут от одной машины до другой с помощью файла etc/netplan/00-installer-config.yaml**
+ В отчёт поместить скрин с содержанием изменённого файла etc/netplan/00-installer-config.yaml.
Для изменения файла etc/netplan/00-installer-config.yaml выполняем команду:
```C
sudo vim etc/netplan/00-installer-config.yaml
```
![screen21.9](screen/screen21.9.1.png)

Отчёт с содержанием изменённого файла etc/netplan/00-installer-config.yaml.

**Пропинговать соединение между машинами**
+ В отчёт поместить скрин с вызовом и выводом использованной команды.
![screen21.9](screen/screen21.9.2.png)

Отчёт с вызовом и выводом  команды `ping` пропинговать соединение между машинами ws1 b ws2 
___
## Part 3. Утилита iperf3
 _В данном задании используются виртуальные машины ws1 и ws2 из Части 2_

## 3.1. Скорость соединения
**Перевести и записать в отчёт: 8 Mbps в MB/s, 100 MB/s в Kbps, 1 Gbps в Mbps**
8 Mbps = 1 MB/s,
100 MB/s = 819200 Kbps,
1 Gbps = 1000 Mbps
## 3.2. Утилита iperf3
**Измерить скорость соединения между ws1 и ws2**
+ В отчёт поместить скрины с вызовом и выводом использованных команд.

Для начала устанавливаем утилиту **iperf3** на обеих машинах (ws1 и ws2). Используем команду:
```C
sudo apt install iperf3
```
![screen24](screen/screen24.png)
![screen25](screen/screen25.png)
Запускаем **iperf3** на машине ws1 в режиме сервера. Для этого выполняем команду:

```
iperf3 -s
```
Чтобы измерить скорость соединения запускаем **iperf** на машине ws2 в режиме клиента. Выполняем команду:
```C
iperf3 -c 192.168.100.10 (фактический IP-адрес ws1)
```
![screen26](screen/screen26.png)
Утилита **iperf3** выполнила тест соединения и вывела результаты, включая скорость передачи данных.

___
## Part 4. Сетевой экран
_В данном задании используются виртуальные машины ws1 и ws2 из Части 2_


## 4.1. Утилита iptables
**Создать файл /etc/firewall.sh, имитирующий фаерволл, на ws1 и ws2:**
```C
#!/bin/sh

# Удаление всех правил в таблице "filter" (по-умолчанию).
iptables –F
iptables -X
```
Создаем файл на обоих машинах ws1 и ws2 командой:
```
sudo vim /etc/firewall.sh
```

**Нужно добавить в файл подряд следующие правила:**

**1) на ws1 применить стратегию когда в начале пишется запрещающее правило, а в конце пишется разрешающее правило (это касается пунктов 4 и 5)**

**2) на ws2 применить стратегию когда в начале пишется разрешающее правило, а в конце пишется запрещающее правило (это касается пунктов 4 и 5)**

**3) открыть на машинах доступ для порта 22 (ssh) и порта 80 (http)**

**4) запретить echo reply (машина не должна "пинговаться”, т.е. должна быть блокировка на OUTPUT)**

**5) разрешить echo reply (машина должна "пинговаться")**
+ В отчёт поместить скрины с содержанием файла /etc/firewall для каждой машины.

+ В отчёт поместить скрины с запуском обоих файлов.
![screen27.2](screen/screen27.2.png)
![screen27.1](screen/screen27.1.png)
файл /etc/firewall.sh, имитирующий фаерволл, на ws1 и ws2

**iptables** - программа для настройки правил фильтрации пакетов и маскирования сетевых адресов.

Все пакеты делятся на три цепочки:
**nput** - обрабатывает входящие пакеты и подключения. 
**forward** - эта цепочка применяется для проходящих соединений. 
**output** - эта цепочка используется для исходящих пакетов и соединений. 
Есть еще две дополнительные цепочки правил:
**prerouting** - в эту цепочку пакет попадает перед обработкой iptables, система еще не знает куда он будет отправлен, в input, output или forward;
**postrouting** - сюда попадают все проходящие пакеты, которые уже прошли цепочку forward.

Для каждого типа пакетов можно установить набор правил, которые по очереди будут проверяться на соответствие с пакетом и если пакет соответствует, то применять к нему указанное в правиле действие:
**ACCEPT** - разрешить прохождение пакета дальше по цепочке правил;
**DROP** - удалить пакет;
**REJECT** - отклонить пакет, отправителю будет отправлено сообщение, что пакет был отклонен;
**LOG** - сделать запись о пакете в лог файл;
**QUEUE** - отправить пакет пользовательскому приложению.

Основные действия, которые позволяет выполнить iptables:
-A - добавить правило в цепочку;
-С - проверить все правила;
-D - удалить правило;
-I - вставить правило с нужным номером;
-L - вывести все правила в текущей цепочке;
-S - вывести все правила;
-F - очистить все правила;
-N - создать цепочку;
-X - удалить цепочку;
-P - установить действие по умолчанию.

Дополнительные опции для правил:
-p - указать протокол, один из tcp, udp, udplite, icmp, icmpv6,esp, ah, sctp,
mh;
-s - указать ip адрес устройства-отправителя пакета;
-d - указать ip адрес получателя;
-i - входной сетевой интерфейс;
-o - исходящий сетевой интерфейс;
-j - выбрать действие, если правило подошло.

**Запустить файлы на обеих машинах командами chmod +x /etc/firewall.sh и /etc/firewall.sh**
+ В отчёте описать разницу между стратегиями, применёнными в первом и втором файлах.

Запускаем команды для машин ws1 и ws2
```C
sudo chmod +x /etc/firewall.sh
sudo /etc/firewall.sh
```
Далее пропинговываем обе машины с помощью команды `ping`. и видим Так как утилита iptabels выполняет первое прочитанное правило, разница между стратегиями заключается в порядке команд. Для машины ubuntu первой стоит команда REJECT - отклонить пакет. Будет выполнятся этот запрет и пинг не пройдет. Для машины ubuntu2 напротив, первым стоит ACCEPT - разрешить прохождение пакета. Пинг проходит.

Пропинговываем обе машины с помощью команды `ping`. 
Видим, что утилита iptabels выполняет первое прочитанное правило, разница между стратегиями заключается в порядке команд.
На ws1: В начале применяется запрещающее правило (iptables -A OUTPUT -p icmp --icmp-type echo-reply -j REJECT), которое блокирует все входящие пакеты. Затем применяется разрешающее правило (iptables -A OUTPUT -p icmp --icmp-type echo-reply -j ACCEPT), которое разрешает все входящие пакеты. Это означает, что все входящие соединения будут блокированы, за исключением пакетов, разрешенных во втором правиле.

На ws2: В начале применяется разрешающее правило (iptables -A OUTPUT -p icmp --icmp-type echo-reply -j ACCEPT), которое разрешает все входящие пакеты. Затем применяется запрещающее правило (iptables -A OUTPUT -p icmp --icmp-type echo-reply -j DROP), которое блокирует все остальные входящие пакеты. Это означает, что все входящие соединения будут разрешены, за исключением пакетов, заблокированных во втором правиле.
![screen28.2](screen/screen28.2.png)
![screen28.1](screen/screen28.1.png)
___
## 4.2. Утилита nmap
**Командой ping найти машину, которая не "пингуется", после чего утилитой nmap показать, что хост машины запущен**
_Проверка: в выводе nmap должно быть сказано: `Host is up`_

+ В отчёт поместить скрины с вызовом и выводом использованных команд ping и nmap.
Командой  `sudo apt install nmap` устанавливаем утилиту **nmap**
Далее с помощь команды
ping 192.168.100.10
```
определяем машину **ws2** которая не пингуется.
С помощью утилиты **nmap** показываем что хост машины запущен:
```C
nmap 192.168.100.10
```
![screen29](screen/screen29.png) 

**Сохранить дампы образов виртуальных машин**
**p.s. Ни в коем случае не сохранять дампы в гит!**
____
## Part 5. Статическая маршрутизация сети

**Поднять пять виртуальных машин (3 рабочие станции (ws11, ws21, ws22) и 2 роутера (r1, r2))**

## 5.1. Настройка адресов машин

![screen30](screen/screen30.png) 
**Настроить конфигурации машин в etc/netplan/00-installer-config.yaml согласно сети на рисунке.**

+ В отчёт поместить скрины с содержанием файла etc/netplan/00-installer-config.yaml для каждой машины.

**Router r1:**
![screen31](screen/screen31.png)

**Router r2:**
![screen32](screen/screen32.png)

**PC - ws11:**
![screen33](screen/screen33.1.png)

**PC - ws21:**
![screen34](screen/screen34.1.png)

**PC - ws22:**
![screen35](screen/screen35.png)


**Перезапустить сервис сети. Если ошибок нет, то командой ip -4 a проверить, что адрес машины задан верно. Также пропинговать ws22 с ws21. Аналогично пропинговать r1 с ws11.**
+ В отчёт поместить скрины с вызовом и выводом использованных команд.

Перезапускаем сервис сети:
```C
sudo netplan apply
```
Командой `ip -4 a` проверяем, что адрес машины задан верно.

адрес машины r1 задан верно:
![screen36](screen/screen36.png)

адрес машины r2 задан верно:
![screen37](screen/screen37.png)

адрес машины ws11 задан верно:
![screen38](screen/screen38.png)

адрес машины ws21 задан верно:
![screen39](screen/screen39.png)

адрес машины ws22 задан верно:
![screen40](screen/screen40.png)


Пропинговываем ws22 с ws21:
![screen41](screen/screen41.png)

Пропинговываем r1 с ws11:
![screen42](screen/screen42.png)
___
## 5.2. Включение переадресации IP-адресов.

**Для включения переадресации IP, выполните команду на роутерах:**
`sysctl -w net.ipv4.ip_forward=1` _При таком подходе переадресация не будет работать после перезагрузки системы._

* В отчёт поместить скрин с вызовом и выводом использованной команды.
Router r1:
![screen43](screen/screen43.png)

Router r2:
![screen44](screen/screen44.png)

**Откройте файл /etc/sysctl.conf и добавьте в него следующую строку:**
`net.ipv4.ip_forward=1` _При использовании этого подхода, IP-переадресация включена на постоянной основе._

+ В отчёт поместить скрин с содержанием изменённого файла /etc/sysctl.conf.
Добавляем строку `net.ipv4.ip_forward=1` в файл /etc/sysctl.conf на роутерах r1 и r2:
![screen45](screen/screen45.png)
___
## 5.3. Установка маршрута по-умолчанию
Пример вывода команды `ip r` после добавления шлюза:
```C
default via 10.10.0.1 dev eth0
10.10.0.0/18 dev eth0 proto kernel scope link src 10.10.0.2
```
**Настроить маршрут по-умолчанию (шлюз) для рабочих станций. Для этого добавить default перед IP роутера в файле конфигураций**

+ В отчёт поместить скрин с содержанием файла etc/netplan/00-installer-config.yaml.
**Вызвать ip r и показать, что добавился маршрут в таблицу маршрутизации**
+ В отчёт поместить скрин с вызовом и выводом использованной команды.

Добавляем **defaut** перед IP роутера в файле конфигураций.
Содержание файла etc/netplan/00-installer-config.yaml для рабочих станций ws11, ws 21, ws22:
![screen45.2](screen/screen45.3.png)

Вызвываем `ip r` и и показываем, что добавился маршрут в таблицу маршрутизации:
![screen45](screen/screen46.3.png)

**Пропинговать с ws11 роутер r2 и показать на r2, что пинг доходит. Для этого использовать команду:**
`tcpdump -tn -i eth1`
* В отчёт поместить скрин с вызовом и выводом использованных команд.

Пингуем c ws11 Router r2
![screen48.1](screen/screen48.1.png)

С помощью команды `tcpdump -tn -i eth1` проверяем на **r2** что пинг доходит:
![screen48.2](screen/screen48.2.png)


___
## 5.4. Добавление статических маршрутов

**Добавить в роутеры r1 и r2 статические маршруты в файле конфигураций. Пример для r1 маршрута в сетку 10.20.0.0/26:**

```C
 # Добавить в конец описания сетевого интерфейса eth1:
 - to: 10.20.0.0
   via: 10.100.0.12
 ```

* В отчёт поместить скрины с содержанием изменённого файла `etc/netplan/00-installer-config.yaml` для каждого роутера.
Добавляем в роутеры r1 и r2 статические маршруты в файле конфигураций:
![screen49](screen/screen49.3.png)

**Вызвать ip r и показать таблицы с маршрутами на обоих роутерах. Пример таблицы на r1:**
```C
10.100.0.0/16 dev eth1 proto kernel scope link src 10.100.0.11
10.20.0.0/26 via 10.100.0.12 dev eth1
10.10.0.0/18 dev eth0 proto kernel scope link src 10.10.0.1
 ```
+ В отчёт поместить скрин с вызовом и выводом использованной команды.

Вызываем `ip r` и показываем таблицы с маршрутами на обоих роутерах:
![screen50](screen/screen50.1.png)

**Запустить команды на ws11:**
```C
ip r list 10.10.0.0/[маска сети] 
ip r list 0.0.0.0/0
 `
+ В отчёт поместить скрин с вызовом и выводом использованных команд.
+ В отчёте объяснить, почему для адреса 10.10.0.0/[маска сети] был выбран маршрут, отличный от 0.0.0.0/0, хотя он попадает под маршрут по-умолчанию.

Отчет с вызовом и выводом используемых команд:
![screen51](screen/screen51.2.png)
Для адреса 10.10.0.0/18 был выбран маршрут, отличный от 0.0.0.0/0, поскольку он является адресом сети и доступен без шлюза.

## 5.5. Построение списка маршрутизаторов
Пример вывода утилиты traceroute после добавления шлюза:
```C
1 10.10.0.1 0 ms 1 ms 0 ms
2 10.100.0.12 1 ms 0 ms 1 ms
3 10.20.0.10 12 ms 1 ms 3 ms
 ```
**Запустить на r1 команду дампа:**
`tcpdump -tnv -i eth0`

**При помощи утилиты traceroute построить список маршрутизаторов на пути от ws11 до ws21**

+ В отчёт поместить скрины с вызовом и выводом использованных команд (tcpdump и traceroute).
+ В отчёте, опираясь на вывод, полученный из дампа на r1, объяснить принцип работы построения пути при помощи traceroute.

Запускаем на r1 команду дампа:
 ```C
sudo tcpdump -tnv -i enp0s8
```
![screen52](screen/screen52.1.png)

При помощи утилиты `traceroute` построим список маршрутизаторов на пути от ws11 до ws21:
![screen53](screen/screen53.png)

Для определения промежуточных маршрутизаторов traceroute отправляет целевому узлу серию ICMP-пакетов (по умолчанию 3 пакета), с каждым шагом увеличивая значение поля TTL («время жизни») на 1. Это поле обычно указывает максимальное количество маршрутизаторов, которое может быть пройдено пакетом. Первая серия пакетов отправляется с TTL, равным 1, и поэтому первый же маршрутизатор возвращает обратно ICMP-сообщение «time exceeded in transit», указывающее на невозможность доставки данных. Traceroute фиксирует адрес маршрутизатора, а также время между отправкой пакета и получением ответа (эти сведения выводятся на монитор компьютера). Затем traceroute повторяет отправку серии пакетов, но уже с TTL, равным 2, что заставляет первый маршрутизатор уменьшить TTL пакетов на единицу и направить их ко второму маршрутизатору. Второй маршрутизатор, получив пакеты с TTL=1, так же возвращает «time exceeded in transit».

## 5.6. Использование протокола ICMP при маршрутизации

**Запустить на r1 перехват сетевого трафика, проходящего через eth0 с помощью команды:**
`tcpdump -n -i eth0 icmp`

**Пропинговать с ws11 несуществующий IP (например, 10.30.0.111) с помощью команды:
`ping -c 1 10.30.0.111**`

+ В отчёт поместить скрин с вызовом и выводом использованных команд.

**Сохранить дампы образов виртуальных машин**
**p.s. Ни в коем случае не сохранять дампы в гит!** 

Запускаем на r1 перехват сетевого трафика, проходящего через eth0 с помощью команды:
`tcpdump -n -i eth0 icmp`:
![screen54](screen/screen54.png)

Пингуем с ws11 несуществующий IP с помощью команды:
`ping -c 1 10.30.0.111**`:
![screen55](screen/screen55.png)

___
##Part 6. Динамическая настройка IP с помощью DHCP
_В данном задании используются виртуальные машины из Части 5_

**Для r2 настроить в файле `/etc/dhcp/dhcpd.conf` конфигурацию службы DHCP:**

**1) указать адрес маршрутизатора по-умолчанию, DNS-сервер и адрес внутренней сети. Пример файла для r2:**
```C
subnet 10.100.0.0 netmask 255.255.0.0 {}

subnet 10.20.0.0 netmask 255.255.255.192
{
    range 10.20.0.2 10.20.0.50;
    option routers 10.20.0.1;
    option domain-name-servers 10.20.0.1;
}
```

Для открытия файла `/etc/dhcp/dhcpd.conf` и его настройки установливаем пакет `isc-dhcp-server` . Этот пакет представляет собой DHCP-сервер, который предоставляет услуги автоматической настройки IP-адресов и других параметров сетевых устройств в сетях, использующих протокол DHCP (Dynamic Host Configuration Protocol).
Для этого используем команду:
```C
sudo apt install isc-dhcp-server
```
Протокол DHCP позволяет сетевым устройствам, таким как компьютеры, мобильные устройства и другие, автоматически получать IP-адреса, маски подсети, шлюзы и другие параметры конфигурации с сервера DHCP. Это упрощает администрирование сети и позволяет избежать конфликтов IP-адресов.

Файл `/etc/dhcp/dhcpd.conf` после настройки конфигурации службы DHCP:
![screen56](screen/screen56.png)

**2) в файле resolv.conf прописать nameserver 8.8.8.8.**
* В отчёт поместить скрины с содержанием изменённых файлов.

Файл **resolv.conf** с внесенными изменениями:
![screen57](screen/screen57.png)


**Перезагрузить службу DHCP командой systemctl restart isc-dhcp-server. Машину ws21 перезагрузить при помощи reboot и через ip a показать, что она получила адрес. Также пропинговать ws22 с ws21.**
+ В отчёт поместить скрины с вызовом и выводом использованных команд.

Перезагружаем службу DHCP командой `systemctl restart isc-dhcp-server`:
![screen58](screen/screen58.png)

Машину ws21 перезагрузапускаем при помощи `reboot` и через `ip a` показываем, что она получила адрес.
![screen59](screen/screen59.png)

Пингуем ws22 с ws21:
![screen60](screen/screen60.png)


**Указать MAC адрес у ws11, для этого в `etc/netplan/00-installer-config.yaml` надо добавить строки: macaddress: `10:10:10:10:10:BA, dhcp4: true`**
+ В отчёт поместить скрин с содержанием изменённого файла etc/netplan/00-installer-config.yaml.

В **etc/netplan/00-installer-config.yaml** добавляем строки: macaddress: 10:10:10:10:10:BA, dhcp4: true
![screen61](screen/screen61.png)


**Для r1 настроить аналогично r2, но сделать выдачу адресов с жесткой привязкой к MAC-адресу (ws11). Провести аналогичные тесты**
+ В отчёте этот пункт описать аналогично настройке для r2.

Для открытия файла r1 `/etc/dhcp/dhcpd.conf` и его настройки установливаем пакет `isc-dhcp-server`
Для этого используем команду:
```C
sudo apt install isc-dhcp-server
```
Файл /etc/dhcp/dhcpd.conf после настройки конфигурации службы DHCP:
![screen62](screen/screen62.png)

В файле resolv.conf на r1 прописываем nameserver 8.8.8.8.
Файл resolv.conf с внесенными изменениями:
![screen63](screen/screen63.png)

Перезагружаем службу DHCP командой `systemctl restart isc-dhcp-server`:
![screen64](screen/screen64.png)

Машину ws11 перезагрузапускаем при помощи `reboot` и через `ip a` показываем, что она получила адрес.
![screen65](screen/screen65.png)

**Запросить с ws21 обновление ip адреса**
+ В отчёте поместить скрины ip до и после обновления.
+ В отчёте описать, какими опциями DHCP сервера пользовались в данном пункте.

ws21 ip адрес до обновления:
![screen66](screen/screen66.png)
Обновляем ip адрес с помощью следующих команд:
```C
sudo dhclient -r enp0s3

sudo dhclient enp0s3
```
ws21 ip адрес после обновления:
![screen67](screen/screen67.png)


**Сохранить дампы образов виртуальных машин**
**p.s. Ни в коем случае не сохранять дампы в гит!**
___
## Part 7. NAT

**В файле /etc/apache2/ports.conf на ws22 и r1 изменить строку Listen 80 на Listen 0.0.0.0:80, то есть сделать сервер Apache2 общедоступным**

+ В отчёт поместить скрин с содержанием изменённого файла.

Устанавливаем Apache на ws22 и r1, выполнив команду:
```C
sudo apt-get install apache2
```
Открываем файл `etc/apache2/ports.conf` на ws22 и r1 с помощью команды:

```C
sudo vim /etc/apache2/ports.conf
```
и изменяем строку Listen 80 на Listen 0.0.0.0:80, то есть сделать сервер Apache2 общедоступны.

Изменение в файле файле /etc/apache2/ports.conf для ws22:

![screen68](screen/screen68.png)

Изменение в файле файле /etc/apache2/ports.conf для r1:

![screen69](screen/screen69.png)

**Запустить веб-сервер Apache командой service apache2 start на ws22 и r1**

+ В отчёт поместить скрины с вызовом и выводом использованной команды.

Запуск веб-сервера Apache командой service apache2 start на ws22 и r1:
![screen70](screen/screen70.png)

**Добавить в фаервол, созданный по аналогии с фаерволом из Части 4, на r2 следующие правила:**

**1) удаление правил в таблице filter - `iptables -F`**


**2) удаление правил в таблице "NAT" - `iptables -F -t nat`**


**3) отбрасывать все маршрутизируемые пакеты - `iptables --policy FORWARD DROP`**

Файл /etc/firewall.sh на r2 со следующими правилами:
![screen71](screen/screen71.png)

**Запускать файл также, как в Части 4**

Запускаем команды:
```C
sudo chmod +x /etc/firewall.sh
sudo /etc/firewall.sh
```

**Проверить соединение между ws22 и r1 командой ping**

_При запуске файла с этими правилами, ws22 не должна "пинговаться" с r1_

+ В отчёт поместить скрины с вызовом и выводом использованной команды.

ping ws22 с r1 после применения настроек файла /etc/firewall.sh на r2:
![screen72](screen/screen72.png)

**Добавить в файл ещё одно правило:**

**4) разрешить маршрутизацию всех пакетов протокола ICMP**
Файл /etc/firewall.sh на r2 со следующими правилами:
![screen73](screen/screen73.png)

**Запускать файл также, как в Части 4**
Запускаем команды:
```C
sudo chmod +x /etc/firewall.sh
sudo /etc/firewall.sh
```

**Проверить соединение между ws22 и r1 командой ping**

_При запуске файла с этими правилами, ws22 должна "пинговаться" с r1_

+ В отчёт поместить скрины с вызовом и выводом использованной команды.
При запуске файла с этими правилами, ws22 пингуется с r1:
![screen74](screen/screen74.png)

**Добавить в файл ещё два правила:**

**5) включить SNAT, а именно маскирование всех локальных ip из локальной сети, находящейся за r2 (по обозначениям из Части 5 - сеть 10.20.0.0)**
_Совет: стоит подумать о маршрутизации внутренних пакетов, а также внешних пакетов с установленным соединением_

**6) включить DNAT на 8080 порт машины r2 и добавить к веб-серверу Apache, запущенному на ws22, доступ извне сети**
_Совет: стоит учесть, что при попытке подключения возникнет новое tcp-соединение, предназначенное ws22 и 80 порту_

* В отчёт поместить скрин с содержанием изменённого файла.

Добавляем еще два правила:
![screen75](screen/screen75.1.png)

**Запускать файл также, как в Части 4**
_Перед тестированием рекомендуется отключить сетевой интерфейс **NAT** (его наличие можно проверить командой ip a) в VirtualBox, если он включен_

***Проверить соединение по TCP для SNAT, для этого с ws22 подключиться к серверу Apache на r1 командой:***
```C
telnet [адрес] [порт]
```
Проверяем соединение по TCP для SNAT, для этого с ws22 подключиться к серверу Apache на r1 командой:
```C
sudo telnet 10.100.0.11 80
```
![screen76](screen/screen76.png)

**Проверить соединение по TCP для DNAT, для этого с r1 подключиться к серверу Apache на ws22 командой telnet (обращаться по адресу r2 и порту 8080)**
+ В отчёт поместить скрины с вызовом и выводом использованных команд.

Проверяем соединение по TCP для DNAT, для этого с r1 подключаемся к серверу Apache на ws22 командой telnet (обращаемся по адресу r2 и порту 8080)
```C
sudo telnet 10.100.0.12 8080
```
![screen77](screen/screen77.png)

**Сохранить дампы образов виртуальных машин**
**p.s. Ни в коем случае не сохранять дампы в гит!**
___

## Part 8. Дополнительно. Знакомство с SSH Tunnels

**В данном задании используются виртуальные машины из Части 5**

**Запустить на r2 фаервол с правилами из Части 7**

**Запустить веб-сервер Apache на ws22 только на localhost (то есть в файле /etc/apache2/ports.conf изменить строку `Listen 80` на `Listen localhost:80`)**

Изменили строку `Listen 80` на `Listen localhost:80`:

![screen78](screen/screen78.png)

**Воспользоваться Local TCP forwarding с ws21 до ws22, чтобы получить доступ к веб-серверу на ws22 с ws21**
Воспользовались Local TCP forwarding с ws21 до ws22, чтобы получить доступ к веб-серверу на ws22 с ws21
![screen79](screen/screen79.png)

**Воспользоваться Remote TCP forwarding c ws11 до ws22, чтобы получить доступ к веб-серверу на ws22 с ws11**

![screen80](screen/screen81.png)

**Для проверки, сработало ли подключение в обоих предыдущих пунктах, перейдите во второй терминал (например, клавишами Alt + F2) и выполните команду:**

```C
telnet 127.0.0.1 [локальный порт]
```
![screen80](screen/screen80.png)

![screen80](screen/screen82.png)


**Сохранить дампы образов виртуальных машин**
p.s. Ни в коем случае не сохранять дампы в гит!